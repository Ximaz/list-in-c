# Specifications for this workflow
#
# The jobs will be trigger on any push/pull_request as long as the main branch
# is not the source of those events.
#
# -----------------------------------------------------------------------------
# |                                 SECRETS                                   |
# -----------------------------------------------------------------------------
# | -> Repository Secrets (not the Environment Secrets)                       |
# -----------------------------------------------------------------------------
#
# PERSONNAL_ACCESS_TOKEN: should be a fine-grained token. Permissions are :
# - Contents: "Read and Write"
# - Metadata (mandatory): "Read Only"
# - Pull Requests: "Read Only"
#
# SSH_PRIVATE_KEY: an SSH private key able to push commits to the ${MIRROR_URL}
# repository (see below). This private key MUST NOT be protected by a
# passphrase as for now, the pixta-dev/repository-mirroring-action action
# doesn't support it
#
# SSH_PRIVATE_KEY_PASSPHRASE: the passphrase used to craft the SSH_PRIVATE_KEY.
#
# -----------------------------------------------------------------------------
# |                                VARIABLES                                  |
# -----------------------------------------------------------------------------
# | -> Repository Variables (not the Environment Variables)                   |
# -----------------------------------------------------------------------------
#
# ARTIFACTSS: space-separated artifactss generated by the `make` command.
#
# MIRROR_URL: the mirror repository URL in an SSH format :
#   git@<host>:<username>/<repository>
#
# -----------------------------------------------------------------------------
# |                                 WORKFLOW                                  |
# -----------------------------------------------------------------------------
#
# The `Workflow Permission` must be set to "Read and Write".
#

name: "ci"

on:
    -   push
    -   pull_request

jobs:
    check-basics:
        runs-on: "ubuntu-latest"
        outputs:
            continue: "${{ steps.basic-check.outputs.continue }}"
        steps:
            -   id: "basic-check"
                continue-on-error: true
                env:
                    ARTIFACTS: "${{ vars.ARTIFACTS }}"
                if: "${{ env.ARTIFACTS }}"
                run: "echo \"continue=1\" >> $GITHUB_OUTPUT"

    basics:
        needs:
            -   "check-basics"
        runs-on: "ubuntu-latest"
        if: "${{ needs.check-basics.outputs.continue == '1' && format('refs/heads/{0}', github.event.repository.default_branch) != github.ref }}"
        container:
            image: "ghcr.io/epitech/coding-style-checker:latest"
        steps:
            -   name: "Checkout"
                uses: "actions/checkout@v4.1.1"
                with:
                    fetch-depth: 0

            -   name: "Temporary files"
                run: "[[ $(find . -type f \\( -name '*.o' -o -name '*.log' -o -name '.env' -o -name '*.so' -o -name '*.a' -o -name '*.gcno' -o -name '*.gcda' \\)) == \"\" ]] && exit 0 || exit 1"

            -   name: "Checking for the artifacts before compilation"
                run: "for a in ${{ vars.ARTIFACTS }} ; do [ ! -f \"${a}\" ]; done"

            -   name: "Check coding style"
                run: "/usr/local/bin/check.sh $(pwd) $(pwd)"

            -   name: "Annotate coding-style errors"
                run: |
                    status=0
                    while IFS= read -r line; do
                        file=$(echo "${line}" | cut -d ':' -f1)
                        pos=$(echo "${line}" | cut -d ':' -f2)
                        type=$(echo "${line}" | cut -d ':' -f3)
                        csid=$(echo "${line}" | cut -d ':' -f4)

                        [[ "${type:1}" == "illegal"* ]] && continue
                        echo "::error file=${file},line=${pos},title=${type:1} ${csid}::${type:1}: ${csid} at ${file}:${pos}"
                        status=1
                    done < coding-style-reports.log
                    rm -f coding-style-reports.log
                    exit "${status}"

            -   name: "Checking make on it's own"
                timeout-minutes: 1
                run: "make && for a in ${{ vars.ARTIFACTS }}; do [ -f \"${a}\" ]; done"

            -   name: "Checking for make relink on it's own"
                timeout-minutes: 1
                run: "[[ $(make) == \"\" ]] && exit 1 || echo 0"

            -   name: "Checking 'all' rule"
                timeout-minutes: 1
                run: "make all && for a in ${{ vars.ARTIFACTS }}; do [ -f \"${a}\" ]; done"

            -   name: "Checking for 'all' make relink"
                timeout-minutes: 1
                run: "[[ $(make all) == \"\" ]] && exit 1 || echo 0"

            -   name: "Checking 'clean' rule"
                timeout-minutes: 1
                run: "make clean && echo $(find . -type d -name '.git' -prune -o \\( -type f \\( -name '*.o' -o -name '.env' -o -name '*.log' -o -name '*.gcno' -o -name '*.gcda' \\) \\) -print) && [[ $(find . -type d -name '.git' -prune -o \\( -type f \\( -name '*.o' -o -name '.env' -o -name '*.log' -o -name '*.gcno' -o -name '*.gcda' \\) \\) -print) == \"\" ]] && exit 0 || exit 1"

            -   name: "Checking 'fclean' rule"
                timeout-minutes: 1
                run: |
                    make
                    make fclean
                    for a in ${{ vars.ARTIFACTS }}; do [ ! -f "${a}" ]; done
                    if [[ $(find . -type d -name '.git' -prune -o \( -type f \( -name '*.o' -o -name '*.log' -o -name '.env' -o -name '*.so' -o -name '*.a' -o -name '*.gcno' -o -name '*.gcda' \) \) -print) == "" ]]; then
                        exit 0
                    else
                        exit 1
                    fi

            -   name: "Checking 're' rule"
                timeout-minutes: 1
                run: |
                    make re
                    for a in ${{ vars.ARTIFACTS }} ; do [ -f "${a}" ]; done

            -   name: "Checking the artifacts rule"
                timeout-minutes: 1
                run: |
                    for a in ${{ vars.ARTIFACTS }}; do make "${a}" && [ -f "${a}" ]; done

            -   name: "Checking for the artifacts make relink"
                timeout-minutes: 1
                run: |
                    for a in ${{ vars.ARTIFACTS }}; do
                        if [[ $(make "${a}") == "" ]]; then exit 1; fi;
                    done

    run-tests:
        needs:
            -   "basics"
        runs-on: "ubuntu-latest"
        if: "${{ format('refs/head/{0}', github.event.repository.default_branch) != github.ref }}"
        container:
            image: "epitechcontent/epitest-docker:latest"
        steps:
            -   name: "Checkout"
                uses: "actions/checkout@v4.1.1"
                with:
                    fetch-depth: 0

            -   name: "Run tests"
                timeout-minutes: 1
                run: "[[ $(grep -E \"^tests_run:\" Makefile) == \"\" ]] && exit 0 || make tests_run"

    check-push-commits:
        runs-on: "ubuntu-latest"
        needs:
            -   "basics"
            -   "run-tests"
        outputs:
            continue: "${{ steps.publishing-check.outputs.continue }}"
        steps:
            -   id: "publishing-check"
                continue-on-error: true
                env:
                    PERSONNAL_ACCESS_TOKEN: "${{ secrets.PERSONNAL_ACCESS_TOKEN }}"
                if: "${{ env.PERSONNAL_ACCESS_TOKEN }}"
                run: "echo \"continue=1\" >> $GITHUB_OUTPUT"

    push-commits:
        needs:
            -   "check-push-commits"
        runs-on: "ubuntu-latest"
        if: "${{ needs.check-push-commits.outputs.continue == '1' && format('refs/heads/{0}', github.event.repository.default_branch) != github.ref }}"
        steps:
            -   name: "Checkout"
                uses: "actions/checkout@v4.1.1"
                with:
                    fetch-depth: 0

            -   name: "Push all commits"
                env:
                    GITHUB_TOKEN: "${{ secrets.PERSONNAL_ACCESS_TOKEN }}"
                run: "git push origin ${{ github.ref_name }}:${{ github.event.repository.default_branch }}"

    check-mirror-commits:
        runs-on: "ubuntu-latest"
        needs:
            -   "push-commits"
        outputs:
            continue: "${{ steps.mirroring-check.outputs.continue }}"
        steps:
            -   id: "mirroring-check"
                continue-on-error: true
                env:
                    MIRROR_URL: "${{ vars.MIRROR_URL }}"
                    SSH_PRIVATE_KEY: "${{ secrets.SSH_PRIVATE_KEY }}"
                if: "${{ env.MIRROR_URL && env.SSH_PRIVATE_KEY }}"
                run: "echo \"continue=1\" >> $GITHUB_OUTPUT"

    mirror-commits:
        needs:
            -   "check-mirror-commits"
        if: "${{ needs.check-mirror-commits.outputs.continue == '1' && github.event_name == 'push' && format('refs/heads/{0}', github.event.repository.default_branch) != github.ref }}"
        runs-on: "ubuntu-latest"
        steps:
            -   name: "Checkout"
                uses: "actions/checkout@v4.1.1"
                with:
                    fetch-depth: 0

            -   name: "Mirror commits"
                uses: "./.github/workflows/repository-mirroring-action"
                with:
                    target_repo_url: "${{ vars.MIRROR_URL }}"
                    ssh_private_key: "${{ secrets.SSH_PRIVATE_KEY }}"
                    ssh_private_key_passphrase: "${{ secrets.SSH_PRIVATE_KEY_PASSPHRASE }}"
